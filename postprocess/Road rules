def apply_road_rules(mask):
    # Apply morphological operations to clean the mask
    kernel = np.ones((5, 5), np.uint8)
    cleaned_mask = cv2.morphologyEx(mask, cv2.MORPH_CLOSE, kernel)
    cleaned_mask = cv2.morphologyEx(cleaned_mask, cv2.MORPH_OPEN, kernel)
    
    # Find contours of the segmented regions
    contours, _ = cv2.findContours(cleaned_mask, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)
    
    # Initialize an empty mask for the final road segments
    final_mask = np.zeros_like(mask)
    
    for contour in contours:
        # Compute the bounding box of the contour
        x, y, w, h = cv2.boundingRect(contour)
        
        # Rule 1: Minimum Road Width
        min_width = 10
        if w < min_width and h < min_width:
            continue
        
        # Rule 2: Connectivity (optional if using a flood fill or similar approach)
        
        # Rule 3: Road Orientation (could be computed by fitting lines, etc.)
        # Here, as a placeholder, we will use the bounding box dimensions
        aspect_ratio = float(w) / h
        if aspect_ratio < 0.1 or aspect_ratio > 10:
            continue
        
        # Rule 4: Area and Shape Constraints
        area = cv2.contourArea(contour)
        if area < 500:  # Example minimum area
            continue
        
        # Rule 5: Boundary Proximity
        if x < 10 or y < 10 or x + w > mask.shape[1] - 10 or y + h > mask.shape[0] - 10:
            continue
        
        # Add the accepted contour to the final mask
        cv2.drawContours(final_mask, [contour], -1, (255), thickness=cv2.FILLED)
    
    return final_mask
